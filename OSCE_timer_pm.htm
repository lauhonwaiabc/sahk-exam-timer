<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>OSCE Exam Timer</title>
    <link rel="stylesheet" href="timer_style.css"/>
    <script src="config/osce_config.js"></script>
    <script src="config/osce_stations.js"></script>
    <script src="config/osce_data_pm.js"></script>
</head>
<body>
<div id="clock">00:00:00</div>
<div id="controls">
    <button id="scheduleStartBtn">Schedule Start</button>
    <button id="startBtn">Start</button>
    <button id="pauseBtn" disabled>Pause</button>
    <button id="stopBtn" disabled>Stop &amp; Reset</button>
    <button id="muteBtn" aria-pressed="true" aria-label="Toggle mute/sound">Mute</button>
    <button id="toggleModeBtn" aria-pressed="false" aria-label="Toggle between Station, Candidate, and Map Modes">
        Switch to Candidate Mode
    </button>
</div>
<div id="startTimeContainer" style="text-align:center;margin:10px 0;">
    <label for="startTimeInput" style="font-weight:700;margin-right:8px;">Start Time (hh:mm:ss):</label>
    <input id="startTimeInput" type="time" step="1"
           style="font-size:1.1em;padding:6px 12px;border-radius:6px;border:1px solid #bbb;width:140px;"/>
    <button id="applyStartTimeBtn"
            style="font-size:1.1em;padding:7px 18px;border-radius:6px;border:none;background:#1976d2;color:white;font-weight:700;cursor:pointer;">
        Apply
    </button>
</div>
<div id="searchContainer" style="display:flex;justify-content:center;align-items:center;margin:10px 0;">
    <input id="searchInput" type="text" placeholder="Enter Candidate ID, Station Name or Station Number"
           style="font-size:1.1em;padding:6px 12px;border-radius:6px;border:1px solid #bbb;width:320px;margin-right:8px;"/>
    <button id="searchBtn"
            style="font-size:1.1em;padding:7px 18px;border-radius:6px;border:none;background:#1976d2;color:white;font-weight:700;cursor:pointer;">
        Search
    </button>
</div>
<div id="topMenu">
    <ul id="sectionsList"></ul>
    <br/>
    <ul id="subsectionsList"></ul>
</div>
<div id="bottomContent">
    <div class="timer" id="timerDisplay">00:00</div>
    <div class="info" id="infoDisplay">Select a session and phase to see information here.</div>
    <div id="stationModeContainer" aria-live="polite"></div>
    <div id="candidateModeContainer" aria-live="polite" style="display:none;"></div>
    <div id="mapModeContainer" aria-live="polite" style="display:none; position: relative; text-align: center;">
        <!-- Map and overlays rendered here -->
        <div id="mapWrapper" style="position:relative; display:inline-block;">
            <img id="mapImage" src="config/OSCE_map.jpg" alt="OSCE Map" style="max-width: 100%; height: auto;"/>
            <svg id="mapSvgOverlay"
                 style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none;"
                 xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 600" preserveAspectRatio="xMidYMid meet">
            </svg>
        </div>
    </div>
</div>
<script>
    (() => {
        // Elements references
        const clockEl = document.getElementById('clock');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const toggleModeBtn = document.getElementById('toggleModeBtn');
        const scheduleStartBtn = document.getElementById('scheduleStartBtn');
        const muteBtn = document.getElementById('muteBtn');
        const sectionsList = document.getElementById('sectionsList');
        const subsectionsList = document.getElementById('subsectionsList');
        const timerDisplay = document.getElementById('timerDisplay');
        const infoDisplay = document.getElementById('infoDisplay');
        const stationModeContainer = document.getElementById('stationModeContainer');
        const candidateModeContainer = document.getElementById('candidateModeContainer');
        const mapModeContainer = document.getElementById('mapModeContainer');
        const searchInput = document.getElementById('searchInput');
        const searchBtn = document.getElementById('searchBtn');
        const startTimeInput = document.getElementById('startTimeInput');
        const applyStartTimeBtn = document.getElementById('applyStartTimeBtn');
        const toHHMM = s => s.slice(0, 5);
        const REST_INDICES = STATION_NAMES.reduce((acc, name, i) => (name === "Rest" ? acc.concat(i) : acc), []);

        let modeIndex = 0;
        let isRunning = false;
        let selectedSessionIndex = 0;
        let selectedPhaseIndex = 0;
        let countdownInterval = null;
        let countdownSecondsLeft = 0;
        let lastSearchValue = '';
        let startTime = null;
        let endTime = null;
        let isMuted = true;
        let timeOffset = 0;
        let beepAudioCtx = null;
        let startTimeStr = START_TIME_PM;
        startTimeInput.value = startTimeStr;

        // Scheduled times array for all sessions/phases
        let scheduledTimes = [];
        let SESSION_TIMES = generateSessionTimes();

        // Function to add seconds to a time string HH:MM:SS
        function addSeconds(timeStr, seconds) {
            let [h, m, s] = timeStr.split(':').map(Number);
            let date = new Date(0, 0, 0, h, m, s);
            date.setSeconds(date.getSeconds() + seconds);
            return date.toTimeString().slice(0, 8);
        }

        // Generate session times strings like "08:00-08:10"
        function generateSessionTimes() {
            let times = [], current = startTimeStr;
            for (const phases of SESSION_PHASES) {
                const totalDuration = phases.reduce((sum, p) => sum + p.duration, 0);
                let next = addSeconds(current, totalDuration);
                times.push(`${toHHMM(current)}-${toHHMM(next)}`);
                current = next;
            }
            return times;
        }

        // Parse HH:MM:SS string to total seconds
        function parseTimeString(str) {
            if (!str) return 0;
            const [h, m, s = 0] = str.split(':').map(Number);
            return h * 3600 + m * 60 + s;
        }

        // Format seconds to HH:MM:SS string
        function formatTimeHMSSec(secs) {
            secs %= 86400;
            const h = Math.floor(secs / 3600);
            const m = Math.floor((secs % 3600) / 60);
            const s = secs % 60;
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }

        // Format seconds to MM:SS string
        function formatTime(s) {
            const m = Math.floor(s / 60);
            s %= 60;
            return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }

        // Recalculate scheduled times based on start time
        function recalculateScheduledTimes() {
            scheduledTimes = [];
            let t = parseTimeString(startTimeStr);
            for (let s = 0; s < SESSION_PHASES.length; s++) {
                scheduledTimes[s] = [];
                for (const phase of SESSION_PHASES[s]) {
                    scheduledTimes[s].push(t);
                    t += phase.duration;
                }
            }
        }

        recalculateScheduledTimes();

        // Audio beep setup
        function initBeep() {
            if (!beepAudioCtx) beepAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function resumeAudioContext() {
            if (beepAudioCtx?.state === 'suspended') beepAudioCtx.resume();
        }

        document.body.addEventListener('click', resumeAudioContext, {once: true});
        document.body.addEventListener('keydown', resumeAudioContext, {once: true});

        function beep(times = 1) {
            if (isMuted) return;
            initBeep();
            let count = 0;

            function play() {
                if (count >= times) return;
                const osc = beepAudioCtx.createOscillator();
                const gain = beepAudioCtx.createGain();
                osc.frequency.value = 1000;
                osc.type = 'square';
                osc.connect(gain);
                gain.connect(beepAudioCtx.destination);
                osc.start();
                setTimeout(() => {
                    osc.stop();
                    count++;
                    setTimeout(play, 150);
                }, 200);
            }

            play();
        }

        // Update clock element with current time
        function updateClock() {
            const now = new Date();
            clockEl.textContent = now.toTimeString().slice(0, 8);
        }

        setInterval(updateClock, 1000);
        updateClock();

        // Enable or disable sections/phases menus during timer run
        function setSessionPhaseMenusEnabled(enabled) {
            const toggleElements = (list, selectedIdx) => {
                [...list.children].forEach((li, idx) => {
                    if (enabled) {
                        li.classList.remove('disabled');
                        li.tabIndex = 0;
                        li.style.pointerEvents = '';
                        li.style.opacity = '';
                    } else {
                        if (idx === selectedIdx) {
                            li.classList.add('disabled', 'selected');
                            li.tabIndex = -1;
                            li.style.pointerEvents = 'none';
                            li.style.opacity = '1';
                        } else {
                            li.classList.add('disabled');
                            li.classList.remove('selected');
                            li.tabIndex = -1;
                            li.style.pointerEvents = 'none';
                            li.style.opacity = '0.5';
                        }
                    }
                });
            };
            toggleElements(sectionsList, selectedSessionIndex);
            toggleElements(subsectionsList, selectedPhaseIndex);
        }

        // Render session sections (Preparation, Break, Session 1..N)
        function renderSections() {
            sectionsList.innerHTML = '';
            for (let i = 0; i < SESSION_PHASES.length; i++) {
                const li = document.createElement('li');
                if (ENABLE_PREPARATION && i === PREPARATION_SESSION_INDEX) {
                    li.textContent = 'Preparation';
                } else if (ENABLE_BREAK && i === BREAK_SESSION_INDEX) {
                    li.textContent = 'Break';
                } else {
                    const baseSessionIndex = i - (ENABLE_PREPARATION ? 1 : 0) - (ENABLE_BREAK && i > BREAK_SESSION_INDEX ? 1 : 0);
                    li.textContent = baseSessionIndex >= 0 ? `Session ${baseSessionIndex + 1}` : `Session ${i + 1}`;
                }
                if (i === selectedSessionIndex) li.classList.add('selected');
                li.addEventListener('click', () => {
                    if (isRunning) return;
                    if (selectedSessionIndex !== i) {
                        selectedSessionIndex = i;
                        selectedPhaseIndex = 0;
                        resetTimerToCurrentPhase();
                        startTime = endTime = null;
                        renderSections();
                        renderPhases();
                        renderBottomContent();
                    }
                });
                sectionsList.appendChild(li);
            }
            setSessionPhaseMenusEnabled(!isRunning);
        }

        // Render phases for selected session
        function renderPhases() {
            subsectionsList.innerHTML = '';
            const phases = SESSION_PHASES[selectedSessionIndex];
            phases.forEach((phase, idx) => {
                const li = document.createElement('li');
                li.textContent = phase.title;
                if (idx === selectedPhaseIndex) li.classList.add('selected');
                li.addEventListener('click', () => {
                    if (isRunning) return;
                    if (selectedPhaseIndex !== idx) {
                        selectedPhaseIndex = idx;
                        resetTimerToCurrentPhase();
                        startTime = endTime = null;
                        renderPhases();
                        renderBottomContent();
                    }
                });
                subsectionsList.appendChild(li);
            });
            setSessionPhaseMenusEnabled(!isRunning);
        }

        // Format a timestamp ms to HH:MM:SS
        function formatAbsoluteTime(ms) {
            return new Date(ms).toTimeString().slice(0, 8);
        }

        // Render the bottom content depending on mode
        function renderBottomContent() {
            const phase = SESSION_PHASES[selectedSessionIndex][selectedPhaseIndex];
            updateTimerDisplay();
            let sessionLabel = '';
            if (ENABLE_PREPARATION && selectedSessionIndex === PREPARATION_SESSION_INDEX) {
                sessionLabel = 'Preparation';
            } else if (ENABLE_BREAK && selectedSessionIndex === BREAK_SESSION_INDEX) {
                sessionLabel = 'Break';
            } else {
                let baseSessionNum = selectedSessionIndex;
                if (ENABLE_PREPARATION && selectedSessionIndex > PREPARATION_SESSION_INDEX) baseSessionNum--;
                if (ENABLE_BREAK) {
                    if (selectedSessionIndex > BREAK_SESSION_INDEX) baseSessionNum -= 1;
                    else if (selectedSessionIndex === BREAK_SESSION_INDEX) baseSessionNum = -1;
                }
                sessionLabel = baseSessionNum >= 0 ? `Session ${baseSessionNum + 1}` : '';
            }
            const heading = 'SAHK Final Examination Preparation Course - OSCE Examination';
            const sessionTime = SESSION_TIMES[selectedSessionIndex] || '';
            const schedSec = scheduledTimes[selectedSessionIndex]?.[selectedPhaseIndex];
            const schedTimeStr = schedSec ? formatTimeHMSSec(schedSec) : '';
            const displayStartTime = isRunning && startTime !== null ? formatAbsoluteTime(startTime) : schedTimeStr;
            const displayEndTime = isRunning && endTime !== null ? formatAbsoluteTime(endTime) : '';
            const sessionLine = isRunning
                ? `${sessionLabel} (${phase.title}), ${sessionTime} (${phase.info})<br><span style="color:#1976d2;">Current Session Time: ${displayStartTime} - ${displayEndTime}</span>`
                : `${sessionLabel} (${phase.title}), ${sessionTime} (${phase.info})<br><span style="color:#1976d2;">Scheduled Start: ${displayStartTime}</span>`;
            infoDisplay.innerHTML = `<div style="font-weight:700;font-size:1em;margin-bottom:6px;text-align:center;">${heading}</div><div style="font-weight:600;font-size:1em;margin-bottom:10px;text-align:center;">${sessionLine}</div>`;

            // Display the selected mode content
            if (modeIndex === 0) {
                renderStationMode();
            } else if (modeIndex === 1) {
                renderCandidateMode();
            } else {
                renderMapMode();
            }
        }

        // Render station mode bottom content
        function renderStationMode() {
            candidateModeContainer.style.display = 'none';
            mapModeContainer.style.display = 'none';
            stationModeContainer.style.display = 'flex';

            const sessionKey = (() => {
                if (ENABLE_PREPARATION && selectedSessionIndex === PREPARATION_SESSION_INDEX) return "Preparation";
                if (ENABLE_BREAK && selectedSessionIndex === BREAK_SESSION_INDEX) return "Break";
                let baseIdx = selectedSessionIndex;
                if (ENABLE_PREPARATION && selectedSessionIndex > PREPARATION_SESSION_INDEX) baseIdx--;
                if (ENABLE_BREAK && selectedSessionIndex > BREAK_SESSION_INDEX) baseIdx--;
                return `Session ${baseIdx + 1}`;
            })();
            const details = osceData[sessionKey];

            if (!details) {
                stationModeContainer.innerHTML = '<p style="text-align:center; color:#666;">No data available.</p>';
                return;
            }
            stationModeContainer.innerHTML = Array(NUM_STATIONS).fill(0).map((_, i) => {
                const candidate = details.Candidate[i] || '—';
                const observer = details.Observer[i] || '—';
                const isRest = REST_INDICES.includes(i) ? ' rest-station' : '';
                return `
          <div class="osce-box${isRest}" tabindex="0" aria-label="Station ${i + 1} details">
            <div class="osce-title">${STATION_NAMES[i]}<br><span style="font-size:0.7em;color:#555;">Station ${i + 1}</span></div>
            <div class="candidate-row"><div class="role-label">Candidate</div><div class="candidate-name">${candidate}</div></div>
            <div class="observer-row"><div class="role-label">Observer</div><div class="candidate-name">${observer}</div></div>
          </div>`;
            }).join('');
            highlightBoxes(lastSearchValue);
        }

        // Render candidate mode bottom content
        function renderCandidateMode() {
            stationModeContainer.style.display = 'none';
            mapModeContainer.style.display = 'none';
            candidateModeContainer.style.display = 'flex';

            const sessionKey = (() => {
                if (ENABLE_PREPARATION && selectedSessionIndex === PREPARATION_SESSION_INDEX) return "Preparation";
                if (ENABLE_BREAK && selectedSessionIndex === BREAK_SESSION_INDEX) return "Break";
                let baseIdx = selectedSessionIndex;
                if (ENABLE_PREPARATION && selectedSessionIndex > PREPARATION_SESSION_INDEX) baseIdx--;
                if (ENABLE_BREAK && selectedSessionIndex > BREAK_SESSION_INDEX) baseIdx--;
                return `Session ${baseIdx + 1}`;
            })();
            const details = osceData[sessionKey];

            if (!details) {
                candidateModeContainer.innerHTML = '<p style="text-align:center; color:#666;">No data available.</p>';
                return;
            }
            const entries = [];
            for (let i = 0; i < NUM_STATIONS; i++) {
                if (details.Candidate[i]) entries.push({
                    number: details.Candidate[i],
                    stationIndex: i,
                    role: 'Candidate'
                });
                if (details.Observer[i]) entries.push({number: details.Observer[i], stationIndex: i, role: 'Observer'});
            }
            entries.sort((a, b) => a.number.localeCompare(b.number));
            candidateModeContainer.innerHTML = entries.map(({number, stationIndex, role}) => {
                let cls = 'candidate-cell' + (role === "Observer" ? " observer-cell" : "") + (REST_INDICES.includes(stationIndex) ? " rest-station" : "");
                return `
          <div class="${cls}" tabindex="0" aria-label="${role} ${number}, Station ${stationIndex + 1}">
            <div class="candidate-number">${number}</div>
            <div class="candidate-role ${role.toLowerCase()}">${role}</div>
            <div class="candidate-station">${STATION_NAMES[stationIndex]}<br><span style="font-size:0.8em;color:#555;">Station ${stationIndex + 1}</span></div>
          </div>`;
            }).join('');
            highlightBoxes(lastSearchValue);
        }

        function renderMapMode() {
            stationModeContainer.style.display = 'none';
            candidateModeContainer.style.display = 'none';
            mapModeContainer.style.display = 'block';

            const sessionKey = (() => {
                if (ENABLE_PREPARATION && selectedSessionIndex === PREPARATION_SESSION_INDEX) return "Preparation";
                if (ENABLE_BREAK && selectedSessionIndex === BREAK_SESSION_INDEX) return "Break";
                let baseIdx = selectedSessionIndex;
                if (ENABLE_PREPARATION && selectedSessionIndex > PREPARATION_SESSION_INDEX) baseIdx--;
                if (ENABLE_BREAK && selectedSessionIndex > BREAK_SESSION_INDEX) baseIdx--;
                return `Session ${baseIdx + 1}`;
            })();
            const details = osceData[sessionKey];
            const svg = document.getElementById('mapSvgOverlay');

            // Clear previous SVG content
            while (svg.firstChild) {
                svg.removeChild(svg.firstChild);
            }

            if (!details) {
                svg.innerHTML = `<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="#666">No data available.</text>`;
                return;
            }

            const search = (lastSearchValue || '').trim().toLowerCase();
            let stationNumSearch = null;
            const match = search.match(/^station\s*(\d{1,2})$/i);
            if (match) {
                const n = parseInt(match[1], 10);
                if (n >= 1 && n <= NUM_STATIONS) {
                    stationNumSearch = n;
                }
            }
            let stationNameIndex = null;
            if (!stationNumSearch) {
                stationNameIndex = STATION_NAMES.findIndex(t => t.toLowerCase().includes(search));
            }

            const createHighlightGroup = (x, y, stationIndex, highlighted) => {
                const SVG_NS = "http://www.w3.org/2000/svg";

                const g = document.createElementNS(SVG_NS, "g");
                g.setAttribute("tabindex", "0");
                g.setAttribute("aria-label", `Station ${stationIndex + 1}: ${STATION_NAMES[stationIndex]}`);
                g.classList.add("station-group");

                // Background rectangle (bigger translucent rect)
                const rectBg = document.createElementNS(SVG_NS, "rect");
                rectBg.setAttribute("x", x - 40);
                rectBg.setAttribute("y", y - 20);
                rectBg.setAttribute("width", 50);
                rectBg.setAttribute("height", 40);
                rectBg.classList.add("station-bg");
                g.appendChild(rectBg);

                // Station number square
                const square = document.createElementNS(SVG_NS, "rect");
                square.setAttribute("x", x - 40);
                square.setAttribute("y", y - 15);
                square.classList.add("station-square");
                if (highlighted) square.classList.add("highlighted");
                g.appendChild(square);

                // Station number text
                const numberText = document.createElementNS(SVG_NS, "text");
                numberText.setAttribute("x", x - 25);
                numberText.setAttribute("y", y + 5);
                numberText.setAttribute("text-anchor", "middle");
                numberText.classList.add("station-number-text");
                numberText.textContent = stationIndex + 1;
                g.appendChild(numberText);

                // Candidate circle
                const candidateCircle = document.createElementNS(SVG_NS, "circle");
                candidateCircle.setAttribute("cx", x);
                candidateCircle.setAttribute("cy", y - 7);
                candidateCircle.classList.add("candidate-circle");
                g.appendChild(candidateCircle);

                // Candidate number text
                const candidateText = document.createElementNS(SVG_NS, "text");
                candidateText.setAttribute("x", x);
                candidateText.setAttribute("y", y - 2);
                candidateText.setAttribute("text-anchor", "middle");
                candidateText.classList.add("candidate-text");
                candidateText.textContent = details.Candidate[stationIndex] || '';
                g.appendChild(candidateText);

                // Observer circle
                const observerCircle = document.createElementNS(SVG_NS, "circle");
                observerCircle.setAttribute("cx", x);
                observerCircle.setAttribute("cy", y + 10);
                observerCircle.classList.add("observer-circle");
                g.appendChild(observerCircle);

                // Observer number text
                const observerText = document.createElementNS(SVG_NS, "text");
                observerText.setAttribute("x", x);
                observerText.setAttribute("y", y + 15);
                observerText.setAttribute("text-anchor", "middle");
                observerText.classList.add("observer-text");
                observerText.textContent = details.Observer[stationIndex] || '';
                g.appendChild(observerText);

                svg.appendChild(g);
            };

            for (let i = 0; i < NUM_STATIONS; i++) {
                let highlighted = false;
                if (search) {
                    const candidate = details.Candidate[i] || '';
                    const observer = details.Observer[i] || '';

                    if (candidate.toLowerCase() === search || observer.toLowerCase() === search) {
                        highlighted = true;
                    }
                    if (stationNumSearch === i + 1) {
                        highlighted = true;
                    }
                    if (stationNameIndex === i) {
                        highlighted = true;
                    }
                }
                const pos = stationPositions[i] || {x: 100 + i * 50, y: 100};
                createHighlightGroup(pos.x, pos.y, i, highlighted);
            }
        }

        function highlightBoxes(searchValue) {
            document.querySelectorAll('.osce-box.highlight, .candidate-cell.highlight').forEach(el => el.classList.remove('highlight'));
            if (!searchValue) return;
            const search = searchValue.trim().toLowerCase();
            let stationNum = null;
            const match = search.match(/^station\s*(\d{1,2})$/i);
            if (match) {
                stationNum = parseInt(match[1], 10);
                if (stationNum < 1 || stationNum > NUM_STATIONS) stationNum = null;
            }
            let stationNameIndex = null;
            if (!stationNum) {
                stationNameIndex = STATION_NAMES.findIndex(t => t.toLowerCase().includes(search));
            }
            if (modeIndex === 1) { // Candidate mode
                candidateModeContainer.querySelectorAll('.candidate-cell').forEach(cell => {
                    const num = cell.querySelector('.candidate-number')?.textContent.trim();
                    if (num === searchValue) cell.classList.add('highlight');
                    if (stationNum) {
                        const label = cell.querySelector('.candidate-station')?.textContent.match(/Station\s*(\d+)/i);
                        if (label && +label[1] === stationNum) cell.classList.add('highlight');
                    }
                    if (stationNameIndex >= 0) {
                        const label = cell.querySelector('.candidate-station')?.textContent.toLowerCase();
                        if (label && label.includes(STATION_NAMES[stationNameIndex].toLowerCase())) cell.classList.add('highlight');
                    }
                });
            } else if (modeIndex === 0) { // Station mode
                stationModeContainer.querySelectorAll('.osce-box').forEach((box, idx) => {
                    const cand = box.querySelector('.candidate-row .candidate-name')?.textContent.trim();
                    const obs = box.querySelector('.observer-row .candidate-name')?.textContent.trim();
                    if (cand === searchValue || obs === searchValue) box.classList.add('highlight');
                    if (stationNum === idx + 1) box.classList.add('highlight');
                    if (stationNameIndex === idx) box.classList.add('highlight');
                });
            }
        }

        // Search functionality
        function doSearch() {
            lastSearchValue = searchInput.value.trim();
            highlightBoxes(lastSearchValue);
            if (modeIndex === 2) { // Map mode
                renderMapMode();
            }
        }

        searchInput.addEventListener('keydown', e => {
            if (e.key === "Enter") doSearch();
        });
        searchBtn.addEventListener('click', doSearch);
        searchInput.addEventListener('input', () => {
            if (!searchInput.value.trim()) {
                lastSearchValue = '';
                highlightBoxes('');
                if (modeIndex === 2) renderMapMode();
            }
        });

        // Timer Display update
        function updateTimerDisplay() {
            timerDisplay.textContent = formatTime(countdownSecondsLeft);
        }

        // Reset timer to currently selected phase duration
        function resetTimerToCurrentPhase() {
            countdownSecondsLeft = SESSION_PHASES[selectedSessionIndex][selectedPhaseIndex].duration;
        }

        // Move to next phase in session
        function moveToNextPhase() {
            let s = selectedSessionIndex;
            let p = selectedPhaseIndex + 1;
            if (p >= SESSION_PHASES[s].length) {
                s++;
                p = 0;
                if (s >= SESSION_PHASES.length) {
                    stopTimers();
                    alert('All sessions completed!');
                    return;
                }
            }
            selectedSessionIndex = s;
            selectedPhaseIndex = p;
            resetTimerToCurrentPhase();
            const dur = SESSION_PHASES[s][p].duration;
            if (endTime) {
                startTime = endTime;
                endTime = startTime + dur * 1000;
            } else {
                startTime = getCorrectedNow();
                endTime = startTime + dur * 1000;
            }
            countdownSecondsLeft = dur;
            renderSections();
            renderPhases();
            renderBottomContent();
            if (isRunning) startCountdownForSelected();
        }

        // Start interval countdown for current phase
        function startCountdownForSelected() {
            clearInterval(countdownInterval);
            updateTimerDisplay();
            countdownInterval = setInterval(() => {
                if (!isRunning) return;
                const now = getCorrectedNow();
                const diff = endTime - now;
                countdownSecondsLeft = diff > 0 ? Math.ceil(diff / 1000) : 0;
                updateTimerDisplay();
                if (countdownSecondsLeft <= 0) {
                    beep(5);
                    moveToNextPhase();
                }
            }, 200);
        }

        // Start timers, enable interface accordingly
        async function startTimers() {
            if (isRunning) return;
            await fetchStandardTimeOffset();
            isRunning = true;
            startBtn.disabled = true;
            pauseBtn.disabled = false;
            stopBtn.disabled = false;
            scheduleStartBtn.disabled = true;
            setSessionPhaseMenusEnabled(false);
            if (countdownSecondsLeft <= 0) resetTimerToCurrentPhase();
            startTime = getCorrectedNow();
            endTime = startTime + countdownSecondsLeft * 1000;
            renderBottomContent();
            startCountdownForSelected();
        }

        // Pause timers
        function pauseTimers() {
            if (!isRunning) return;
            isRunning = false;
            startBtn.disabled = false;
            pauseBtn.disabled = true;
            stopBtn.disabled = false;
            scheduleStartBtn.disabled = false;
            clearInterval(countdownInterval);
            const diff = endTime - getCorrectedNow();
            countdownSecondsLeft = diff > 0 ? Math.ceil(diff / 1000) : 0;
            startTime = endTime = null;
            setSessionPhaseMenusEnabled(true);
            updateTimerDisplay();
        }

        // Stop and reset timers
        function stopTimers() {
            isRunning = false;
            startBtn.disabled = false;
            pauseBtn.disabled = true;
            stopBtn.disabled = true;
            scheduleStartBtn.disabled = false;
            clearInterval(countdownInterval);
            resetTimerToCurrentPhase();
            startTime = null;
            endTime = null;
            updateTimerDisplay();
            renderBottomContent();
            setSessionPhaseMenusEnabled(true);
        }

        // Schedule start button handler
        scheduleStartBtn.onclick = () => {
            const now = new Date();
            const nowSeconds = now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds();
            let found = false;
            outerLoop: for (let s = 0; s < scheduledTimes.length; s++) {
                for (let p = 0; p < scheduledTimes[s].length; p++) {
                    const phaseStart = scheduledTimes[s][p];
                    let phaseEnd;
                    if (p + 1 < scheduledTimes[s].length) {
                        phaseEnd = scheduledTimes[s][p + 1];
                    } else if (s + 1 < scheduledTimes.length) {
                        phaseEnd = scheduledTimes[s + 1][0];
                    } else {
                        phaseEnd = phaseStart + SESSION_PHASES[s][p].duration;
                    }
                    if (nowSeconds >= phaseStart && nowSeconds < phaseEnd) {
                        selectedSessionIndex = s;
                        selectedPhaseIndex = p;
                        countdownSecondsLeft = phaseEnd - nowSeconds;
                        startTime = getCorrectedNow();
                        endTime = startTime + countdownSecondsLeft * 1000;
                        found = true;
                        break outerLoop;
                    }
                }
            }
            if (!found) {
                selectedSessionIndex = 0;
                selectedPhaseIndex = 0;
                resetTimerToCurrentPhase();
                startTime = getCorrectedNow();
                endTime = startTime + countdownSecondsLeft * 1000;
            }
            renderSections();
            renderPhases();
            renderBottomContent();
            startTimers();
        };
        startBtn.onclick = startTimers;
        pauseBtn.onclick = pauseTimers;
        stopBtn.onclick = stopTimers;

        // Mute button toggle
        muteBtn.onclick = () => {
            isMuted = !isMuted;
            muteBtn.textContent = isMuted ? 'Mute' : 'Sound On';
            muteBtn.setAttribute('aria-pressed', (!isMuted).toString());
        };

        // Toggle mode button cycles between Station -> Candidate -> Map Modes
        toggleModeBtn.onclick = () => {
            modeIndex = (modeIndex + 1) % 3;
            if (modeIndex === 0) {
                toggleModeBtn.textContent = "Switch to Candidate Mode";
                toggleModeBtn.setAttribute('aria-pressed', 'false');
            } else if (modeIndex === 1) {
                toggleModeBtn.textContent = "Switch to Map Mode";
                toggleModeBtn.setAttribute('aria-pressed', 'false');
            } else {
                toggleModeBtn.textContent = "Switch to Station Mode";
                toggleModeBtn.setAttribute('aria-pressed', 'false');
            }
            renderBottomContent();
            highlightBoxes(lastSearchValue); // refresh highlight for current mode
        };

        // Apply start time input change
        applyStartTimeBtn.onclick = () => {
            startTimeStr = startTimeInput.value || START_TIME_PM;
            recalculateScheduledTimes();
            SESSION_TIMES = generateSessionTimes();
            renderSections();
            renderPhases();
            renderBottomContent();
        };

        // Periodic scheduled time event to auto start at right session/phase
        setInterval(() => {
            if (isRunning) return;
            const now = new Date();
            const nowSec = now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds();
            outerLoop: for (let s = 0; s < scheduledTimes.length; s++) {
                for (let p = 0; p < scheduledTimes[s].length; p++) {
                    if (Math.abs(nowSec - scheduledTimes[s][p]) < 1) {
                        if (selectedSessionIndex !== s || selectedPhaseIndex !== p) {
                            selectedSessionIndex = s;
                            selectedPhaseIndex = p;
                            resetTimerToCurrentPhase();
                            startTime = endTime = null;
                            renderSections();
                            renderPhases();
                            renderBottomContent();
                        }
                        startTimers();
                        break outerLoop;
                    }
                }
            }
        }, 200);

        // Fetch standard time from worldtimeapi for sync (returns timestamp in ms)
        async function fetchStandardTime() {
            try {
                const response = await fetch('http://worldtimeapi.org/api/ip');
                const data = await response.json();
                const timeStr = new Date(data.datetime).toTimeString().slice(0, 8);
                clockEl.textContent = timeStr;
                return new Date(data.datetime).getTime(); // timestamp in ms
            } catch (e) {
                console.error('Error fetching standard time, falling back to local time', e);
                clockEl.textContent = new Date().toTimeString().slice(0, 8);
                return Date.now();
            }
        }

        // Fetch standard time offset for better timer accuracy
        async function fetchStandardTimeOffset() {
            try {
                const response = await fetch('http://worldtimeapi.org/api/ip');
                const data = await response.json();
                const standardTime = new Date(data.datetime).getTime();
                timeOffset = standardTime - Date.now();
            } catch (e) {
                console.error('Failed to fetch standard time, using local time fallback', e);
                timeOffset = 0;
            }
        }

        function getCorrectedNow() {
            return Date.now() + timeOffset;
        }

        // Initial render calls
        renderSections();
        renderPhases();
        resetTimerToCurrentPhase();
        renderBottomContent();
        startTime = endTime = null;

        fetchStandardTime();
        setInterval(fetchStandardTime, 60000);
    })();
</script>
</body>
</html>
